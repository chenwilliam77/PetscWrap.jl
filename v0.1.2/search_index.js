var documenterSearchIndex = {"docs":
[{"location":"api/ksp/#PETSc-KSP","page":"PETSc KSP","title":"PETSc KSP","text":"","category":"section"},{"location":"api/ksp/","page":"PETSc KSP","title":"PETSc KSP","text":"Modules = [PetscWrap]\nPages   = [\"ksp.jl\"]","category":"page"},{"location":"api/ksp/#PetscWrap.KSPCreate-Tuple{Any,PetscKSP}","page":"PETSc KSP","title":"PetscWrap.KSPCreate","text":"KSPCreate(comm::MPI.Comm, ksp::PetscKSP)\n\nWrapper for KSPCreate\n\n\n\n\n\n","category":"method"},{"location":"api/ksp/#PetscWrap.KSPDestroy-Tuple{PetscKSP}","page":"PETSc KSP","title":"PetscWrap.KSPDestroy","text":"KSPDestroy(ksp::PetscKSP)\n\nWrapper to KSPDestroy\n\n\n\n\n\n","category":"method"},{"location":"api/ksp/#PetscWrap.KSPSetFromOptions-Tuple{PetscKSP}","page":"PETSc KSP","title":"PetscWrap.KSPSetFromOptions","text":"KSPSetFromOptions(ksp::PetscKSP)\n\nWrapper to KSPSetFromOptions\n\n\n\n\n\n","category":"method"},{"location":"api/ksp/#PetscWrap.KSPSetOperators-Tuple{PetscKSP,PetscMat,PetscMat}","page":"PETSc KSP","title":"PetscWrap.KSPSetOperators","text":"KSPSetOperators(ksp::PetscKSP, Amat::PetscMat, Pmat::PetscMat)\n\nWrapper for KSPSetOperators\n\n\n\n\n\n","category":"method"},{"location":"api/ksp/#PetscWrap.KSPSetUp-Tuple{PetscKSP}","page":"PETSc KSP","title":"PetscWrap.KSPSetUp","text":"KSPSetUp(ksp::PetscKSP)\n\nWrapper to KSPSetUp\n\n\n\n\n\n","category":"method"},{"location":"api/ksp/#PetscWrap.KSPSolve-Tuple{PetscKSP,PetscVec,PetscVec}","page":"PETSc KSP","title":"PetscWrap.KSPSolve","text":"KSPSolve(ksp::PetscKSP, b::PetscVec, x::PetscVec)\n\nWrapper for KSPSolve\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PETSc-Vec","page":"PETSc Vec","title":"PETSc Vec","text":"","category":"section"},{"location":"api/vec/","page":"PETSc Vec","title":"PETSc Vec","text":"Modules = [PetscWrap]\nPages   = [\"vec.jl\"]","category":"page"},{"location":"api/vec/#Base.setindex!-Tuple{PetscVec,Number,Integer}","page":"PETSc Vec","title":"Base.setindex!","text":"Base.setindex!(vec::PetscVec, value::Number, row::Integer)\n\nrow must be in [1,size(vec)], i.e indexing starts at 1 (Julia).\n\nImplementation\n\nFor some unkwnown reason, calling VecSetValue fails.\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecAssemblyBegin-Tuple{PetscVec}","page":"PETSc Vec","title":"PetscWrap.VecAssemblyBegin","text":"VecAssemblyBegin(vec::PetscVec)\n\nWrapper to VecAssemblyBegin\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecAssemblyEnd-Tuple{PetscVec}","page":"PETSc Vec","title":"PetscWrap.VecAssemblyEnd","text":"VecAssemblyEnd(vec::PetscVec)\n\nWrapper to VecAssemblyEnd\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecCreate-Tuple{Any,PetscVec}","page":"PETSc Vec","title":"PetscWrap.VecCreate","text":"VecCreate(comm, vec::PetscVec)\n\nWrapper to VecCreate\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecDestroy-Tuple{PetscVec}","page":"PETSc Vec","title":"PetscWrap.VecDestroy","text":"VecDestroy(vec::PetscVec)\n\nWrapper to VecDestroy\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecDuplicate-Tuple{PetscVec}","page":"PETSc Vec","title":"PetscWrap.VecDuplicate","text":"VecDuplicate(vec::PetscVec)\n\nWrapper for VecDuplicate, except that it returns the new vector instead of taking it as an input.\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecGetArray","page":"PETSc Vec","title":"PetscWrap.VecGetArray","text":"VecGetArray(vec::PetscVec, own = false)\n\nWrapper for VecGetArray.\n\nWarning\n\nI am not confortable at all with memory management, both on the C side and on the Julia side. Use this at you own risk.\n\nAccording to Julia documentation, own optionally specifies whether Julia should take ownership of the memory, calling free on the pointer when the array is no longer referenced.\"\n\n\n\n\n\n","category":"function"},{"location":"api/vec/#PetscWrap.VecGetLocalSize-Tuple{PetscVec}","page":"PETSc Vec","title":"PetscWrap.VecGetLocalSize","text":"VecGetLocalSize(vec::PetscVec)\n\nWrapper for VecGetLocalSize\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecGetOwnershipRange-Tuple{PetscVec}","page":"PETSc Vec","title":"PetscWrap.VecGetOwnershipRange","text":"VecGetOwnershipRange(vec::PetscVec)\n\nWrapper to VecGetOwnershipRange\n\nHowever, the result (rstart, rend) is such that mat[rstart:rend] are the rows handled by the local processor. This is different from the default PETSc result where the indexing starts at one and where rend-1 is last row handled by the local processor.\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecGetSize-Tuple{PetscVec}","page":"PETSc Vec","title":"PetscWrap.VecGetSize","text":"VecGetSize(vec::PetscVec)\n\nWrapper for VecGetSize\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecRestoreArray-Tuple{PetscVec,Any}","page":"PETSc Vec","title":"PetscWrap.VecRestoreArray","text":"VecRestoreArray(vec::PetscVec, array_ref)\n\nWrapper for VecRestoreArray. array_ref is obtained from VecGetArray\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecSetFromOptions-Tuple{PetscVec}","page":"PETSc Vec","title":"PetscWrap.VecSetFromOptions","text":"VecSetFromOptions(vec::PetscVec)\n\nWrapper to VecSetFromOptions\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecSetSizes-Tuple{PetscVec,Any,Any}","page":"PETSc Vec","title":"PetscWrap.VecSetSizes","text":"VecSetSizes(vec::PetscVec, nrows_loc, nrows_glo)\n\nWrapper to VecSetSizes\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecSetUp-Tuple{PetscVec}","page":"PETSc Vec","title":"PetscWrap.VecSetUp","text":"VecSetUp(vec::PetscVec)\n\nWrapper to VecSetUp\n\n\n\n\n\n","category":"method"},{"location":"api/vec/#PetscWrap.VecSetValues","page":"PETSc Vec","title":"PetscWrap.VecSetValues","text":"VecSetValues(vec::PetscVec, I::Vector{PetscInt}, V::Array{PetscScalar}, mode::InsertMode = INSERT_VALUES)\n\nWrapper to VecSetValues. Indexing starts at 1 (Julia)\n\n\n\n\n\n","category":"function"},{"location":"api/vec/#PetscWrap.VecView","page":"PETSc Vec","title":"PetscWrap.VecView","text":"VecView(vec::PetscVec, viewer::PetscViewer = C_NULL)\n\nWrapper to VecView\n\n\n\n\n\n","category":"function"},{"location":"api/vec/#PetscWrap.create_vector","page":"PETSc Vec","title":"PetscWrap.create_vector","text":"create_vector(nrows, nrows_loc = PETSC_DECIDE)\n\nCreate a PetscVec matrix of global size (nrows).\n\n\n\n\n\n","category":"function"},{"location":"api/vec/#PetscWrap.vec2array-Tuple{PetscVec}","page":"PETSc Vec","title":"PetscWrap.vec2array","text":"vec2array(vec::PetscVec)\n\nConvert a PetscVec into a Julia Array. Allocation is involved in the process since the PetscVec allocated by PETSC is copied into a freshly allocated array. If you prefer not to allocate memory, use VectGetArray and VecRestoreArray\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PETSc-Mat","page":"PETSc Mat","title":"PETSc Mat","text":"","category":"section"},{"location":"api/mat/","page":"PETSc Mat","title":"PETSc Mat","text":"Modules = [PetscWrap]\nPages   = [\"mat.jl\"]","category":"page"},{"location":"api/mat/#PetscWrap.PetscMat","page":"PETSc Mat","title":"PetscWrap.PetscMat","text":"A Petsc matrix, actually just a pointer to the actual C matrix\n\n\n\n\n\n","category":"type"},{"location":"api/mat/#Base.setindex!-Tuple{PetscMat,Number,Integer,Integer}","page":"PETSc Mat","title":"Base.setindex!","text":"row and col must be in [1,size(mat)], i.e indexing starts at 1 (Julia).\n\nImplementation\n\nFor some unkwnown reason, calling MatSetValue fails.\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatAssemblyBegin-Tuple{PetscMat,PetscWrap.MatAssemblyType}","page":"PETSc Mat","title":"PetscWrap.MatAssemblyBegin","text":"Wrapper to MatAssemblyBegin\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatAssemblyEnd-Tuple{PetscMat,PetscWrap.MatAssemblyType}","page":"PETSc Mat","title":"PetscWrap.MatAssemblyEnd","text":"Wrapper to MatAssemblyEnd\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatCreate-Tuple{Any,PetscMat}","page":"PETSc Mat","title":"PetscWrap.MatCreate","text":"MatCreate(comm, mat::PetscMat)\n\nWrapper to MatCreate\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatCreateVecs-Tuple{PetscMat,PetscVec,PetscVec}","page":"PETSc Mat","title":"PetscWrap.MatCreateVecs","text":"Wrapprt to MatCreateVecs\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatDestroy-Tuple{PetscMat}","page":"PETSc Mat","title":"PetscWrap.MatDestroy","text":"MatDestroy(mat::PetscMat)\n\nWrapper to MatDestroy\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatGetOwnershipRange-Tuple{PetscMat}","page":"PETSc Mat","title":"PetscWrap.MatGetOwnershipRange","text":"MatGetOwnershipRange(mat::PetscMat)\n\nWrapper to MatGetOwnershipRange\n\nHowever, the result (rstart, rend) is such that mat[rstart:rend] are the rows handled by the local processor. This is different from the default PETSc result where the indexing starts at one and where rend-1 is last row handled by the local processor.\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatSetFromOptions-Tuple{PetscMat}","page":"PETSc Mat","title":"PetscWrap.MatSetFromOptions","text":"MatSetFromOptions(mat::PetscMat)\n\nWrapper to MatSetFromOptions\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatSetSizes-Tuple{PetscMat,Any,Any,Any,Any}","page":"PETSc Mat","title":"PetscWrap.MatSetSizes","text":"MatSetSizes(mat::PetscMat, nrows_loc, ncols_loc, nrows_glo, ncols_glo)\n\nWrapper to MatSetSizes\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatSetUp-Tuple{PetscMat}","page":"PETSc Mat","title":"PetscWrap.MatSetUp","text":"MatSetUp(mat::PetscMat)\n\nWrapper to MatSetUp\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatSetValues-Tuple{PetscMat,Array{Int32,1},Array{Int32,1},Array{Float64,N} where N,PetscWrap.InsertMode}","page":"PETSc Mat","title":"PetscWrap.MatSetValues","text":"MatSetValues(mat::PetscMat, I::Vector{PetscInt}, J::Vector{PetscInt}, V::Array{PetscScalar}, mode::InsertMode)\n\nWrapper to MatSetValues. Indexing starts at 1 (Julia)\n\n\n\n\n\n","category":"method"},{"location":"api/mat/#PetscWrap.MatView","page":"PETSc Mat","title":"PetscWrap.MatView","text":"MatView(mat::PetscMat, viewer::PetscViewer = C_NULL)\n\nWrapper to MatView\n\n\n\n\n\n","category":"function"},{"location":"api/mat/#PetscWrap.create_matrix","page":"PETSc Mat","title":"PetscWrap.create_matrix","text":"create_matrix(nrows, ncols, nrows_loc = PETSC_DECIDE, ncols_loc = PETSC_DECIDE)\n\nCreate a PetscMat matrix of global size (nrows, ncols).\n\n\n\n\n\n","category":"function"},{"location":"example/example1/#A-first-demo","page":"A first demo","title":"A first demo","text":"","category":"section"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"This example serves as a test since this project doesn't have a \"testing\" procedure yet. In this example, the equation u(x) = 2 with u(0) = 0 is solved on the domain 01 using a backward finite difference scheme.","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"In this example, PETSc legacy method names are used. For more fancy names, check the next example.","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Note that the way we achieve things in the document can be highly improved and the purpose of this example is only demonstrate some method calls to give an overview.","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"To run this example, execute : mpirun -n your_favorite_positive_integer julia example1.jl","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Import package","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"using PetscWrap","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Initialize PETSc. Either without arguments, calling PetscInitialize() or using \"command-line\" arguments. To do so, either provide the arguments as one string, for instance PetscInitialize(\"-ksp_monitor_short -ksp_gmres_cgs_refinement_type refine_always\") or provide each argument in separate strings : PetscInitialize([\"-ksp_monitor_short\", \"-ksp_gmres_cgs_refinement_type\", \"refine_always\")","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"PetscInitialize()","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Number of mesh points and mesh step","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"n = 11\nΔx = 1. / (n - 1)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Create a matrix and a vector","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"A = MatCreate()\nb = VecCreate()","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Set the size of the different objects, leaving PETSC to decide how to distribute. Note that we should set the number of preallocated non-zeros to increase performance.","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"MatSetSizes(A, PETSC_DECIDE, PETSC_DECIDE, n, n)\nVecSetSizes(b, PETSC_DECIDE, n)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"We can then use command-line options to set our matrix/vectors.","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"MatSetFromOptions(A)\nVecSetFromOptions(b)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Finish the set up","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"MatSetUp(A)\nVecSetUp(b)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Let's build the right hand side vector. We first get the range of rows of b handled by the local processor. The rstart, rend = *GetOwnershipRange methods differ a little bit from PETSc API since the two integers it returns are the effective Julia range of rows handled by the local processor. If n is the total number of rows, then rstart ∈ [1,n] and rend is the last row handled by the local processor.","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"b_start, b_end = VecGetOwnershipRange(b)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Now let's build the right hand side vector. Their are various ways to do this, this is just one.","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"n_loc = VecGetLocalSize(b) ## Note that n_loc = b_end - b_start + 1...\nVecSetValues(b, collect(b_start:b_end), 2 * ones(n_loc))","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"And here is the differentiation matrix. Rembember that PETSc.MatSetValues simply ignores negatives rows indices.","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"A_start, A_end = MatGetOwnershipRange(A)\nfor i in A_start:A_end\n    A[i, i-1:i] = [-1. 1.] / Δx\nend","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Set boundary condition (only the proc handling index 1 is acting)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"(b_start == 1) && (b[1] = 0.)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Assemble matrices","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"MatAssemblyBegin(A, MAT_FINAL_ASSEMBLY)\nVecAssemblyBegin(b)\nMatAssemblyEnd(A, MAT_FINAL_ASSEMBLY)\nVecAssemblyEnd(b)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"At this point, you can inspect A and b using the viewers (only stdout for now), simply call MatView(A) and/or VecView(b)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Set up the linear solver","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"ksp = KSPCreate()\nKSPSetOperators(ksp, A, A)\nKSPSetFromOptions(ksp)\nKSPSetUp(ksp)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Solve the system. We first allocate the solution using the VecDuplicate method.","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"x = VecDuplicate(b)\nKSPSolve(ksp, b, x)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Print the solution","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"VecView(x)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Access the solution (this part is under development), getting a Julia array; and then restore it","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"array, ref = VecGetArray(x) # do something with array\nVecRestoreArray(x, ref)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Free memory","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"MatDestroy(A)\nVecDestroy(b)\nVecDestroy(x)","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"Finalize Petsc","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"PetscFinalize()\n","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"","category":"page"},{"location":"example/example1/","page":"A first demo","title":"A first demo","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/init/#Initialization","page":"Initialization","title":"Initialization","text":"","category":"section"},{"location":"api/init/","page":"Initialization","title":"Initialization","text":"Modules = [PetscWrap]\nPages   = [\"init.jl\"]","category":"page"},{"location":"api/init/#PetscWrap.PetscFinalize-Tuple{}","page":"Initialization","title":"PetscWrap.PetscFinalize","text":"Wrapper to PetscFinalize\n\n\n\n\n\n","category":"method"},{"location":"api/init/#PetscWrap.PetscInitialize-Tuple{Array{String,1},String,String}","page":"Initialization","title":"PetscWrap.PetscInitialize","text":"Wrapper to PetscInitializeNoPointers\n\nImplementation\n\nI don't know if I am supposed to use PetscInt or not...\n\n\n\n\n\n","category":"method"},{"location":"api/init/#PetscWrap.PetscInitialize-Tuple{}","page":"Initialization","title":"PetscWrap.PetscInitialize","text":"Wrapper to PetscInitializeNoArguments\n\n\n\n\n\n","category":"method"},{"location":"example/example2/#Same-with-fancy-names","page":"Same with fancy names","title":"Same with fancy names","text":"","category":"section"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"This example does more or less the same things as the first example, but using non regular API function names.","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"This example serves as a test since this project doesn't have a \"testing\" procedure yet. In this example, the equation u(x) = 2 with u(0) = 0 is solved on the domain 01 using a backward finite difference scheme.","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Note that the way we achieve things in the document can be highly improved and the purpose of this example is only demonstrate some method calls to give an overview.","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"To run this example, execute : mpirun -n your_favorite_positive_integer julia example2.jl","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Import package","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"using PetscWrap","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Initialize PETSc. Either without arguments, calling PetscInitialize() or using \"command-line\" arguments. To do so, either provide the arguments as one string, for instance PetscInitialize(\"-ksp_monitor_short -ksp_gmres_cgs_refinement_type refine_always\") or provide each argument in separate strings : PetscInitialize([\"-ksp_monitor_short\", \"-ksp_gmres_cgs_refinement_type\", \"refine_always\")","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"PetscInitialize()","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Number of mesh points and mesh step","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"n = 11\nΔx = 1. / (n - 1)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Create a matrix of size (n,n) and a vector of size (n)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"A = create_matrix(n, n)\nb = create_vector(n)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"We can then use command-line options to set our matrix/vectors.","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"set_from_options!(A)\nset_from_options!(b)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Finish the set up","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"set_up!(A)\nset_up!(b)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Let's build the right hand side vector. We first get the range of rows of b handled by the local processor. The rstart, rend = *GetOwnershipRange methods differ a little bit from PETSc API since the two integers it returns are the effective Julia range of rows handled by the local processor. If n is the total number of rows, then rstart ∈ [1,n] and rend is the last row handled by the local processor.","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"b_start, b_end = get_range(b)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Now let's build the right hand side vector. Their are various ways to do this, this is just one.","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"n_loc = length(b) ## Note that n_loc = b_end - b_start + 1...\nb[b_start:b_end] = 2 * ones(n_loc)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"And here is the differentiation matrix. Rembember that PETSc.MatSetValues simply ignores negatives rows indices.","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"A_start, A_end = get_range(A)\nfor i in A_start:A_end\n    A[i, i-1:i] = [-1. 1.] / Δx\nend","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Set boundary condition (only the proc handling index 1 is acting)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"(b_start == 1) && (b[1] = 0.)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Assemble matrices","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"assemble!(A)\nassemble!(b)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"At this point, you can inspect A and b using the viewers (only stdout for now), simply call MatView(A) and/or VecView(b)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Set up the linear solver","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"ksp = create_ksp(A)\nset_from_options!(ksp)\nset_up!(ksp)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Solve the system","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"x = solve(ksp, b)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Print the solution","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"VecView(x)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Free memory","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"destroy!(A)\ndestroy!(b)\ndestroy!(x)","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"Finalize Petsc","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"PetscFinalize()\n","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"","category":"page"},{"location":"example/example2/","page":"Same with fancy names","title":"Same with fancy names","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PetscWrap","category":"page"},{"location":"#PetscWrap.jl","page":"Home","title":"PetscWrap.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the examples or the API.","category":"page"}]
}
